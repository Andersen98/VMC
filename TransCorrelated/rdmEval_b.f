C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (master-db54337a6) - 29 Jul 2019 10:54
C
C  Differentiation of evalgrad1rdm in reverse (adjoint) mode:
C   gradient     of useful results: rdm
C   with respect to varying inputs: rdm jai
C   RW status of diff variables: ketj:(loc) brajgiven:(loc) rdm:in-zero
C                jai:out sinv:(loc)
C
C
C
C************************************************
C evalRDM
C************************************************
      SUBROUTINE EVALGRAD1RDM_B(bra, jai, jaib, sinv, sinvb, ketj, ketjb
     +                          , brajgiven, brajgivenb, norbs, brancol
     +                          , sinvncol, ketjncol, brajgivenncol, 
     +                          nelec, rdm, rdmb, orb1, orb2, dets)
      IMPLICIT NONE
C
C
      INTEGER norbs, nelec, orb1, orb2, i, j, IND, indupper
      INTEGER brancol, sinvncol, ketjncol, ind1, ind2, ind3
      INTEGER brajgivenncol
C
      REAL*8 bra(2*norbs*nelec), dets(2), MULTREAL
      REAL*8 detsb(2)
      REAL*8 jai(norbs), rdm
      REAL*8 jaib(norbs), rdmb
      REAL*8 sinv(2*nelec*nelec), brajgiven(2*norbs*nelec)
      REAL*8 sinvb(2*nelec*nelec), brajgivenb(2*norbs*nelec)
      REAL*8 ketj(2*norbs*nelec)
      REAL*8 ketjb(2*norbs*nelec)
C
      REAL*8 trsinvs(2), rdmcmplx(2), dummy1(2), dummy2(2)
      REAL*8 trsinvsb(2), dummy1b(2), dummy2b(2)
      REAL*8 s(2*nelec*nelec)
      REAL*8 sb(2*nelec*nelec)
      REAL*8 braj(2*norbs*nelec)
      REAL*8 brajb(2*norbs*nelec)
      REAL*8 intermediate(2*nelec)
      REAL*8 intermediateb(2*nelec)
      REAL*8 intermediate2(2*nelec)
      REAL*8 intermediate2b(2*nelec)
      INTEGER result1
      INTEGER result2
      REAL*8 result3
      REAL*8 result3b
      REAL*8 result10
      REAL*8 result10b
      INTEGER ii1
C
      CALL EVALBRAJ(braj, bra, jai, brancol, nelec, norbs)
Cintermediate = ketJ * Sinv
C
      DO j=1,nelec
        intermediate(2*j-1) = 0.0
        intermediate(2*j) = 0.0
        DO i=1,nelec
          CALL PUSHINTEGER4(ind1)
          ind1 = IND(orb2, i - 1, ketjncol)
          CALL PUSHINTEGER4(ind2)
          ind2 = IND(i - 1, j - 1, sinvncol)
          CALL MULTCMPLX(ketj(2*ind1-1), ketj(2*ind1), sinv(2*ind2-1), 
     +                   sinv(2*ind2), dummy1)
C
          intermediate(2*j-1) = intermediate(2*j-1) + dummy1(1)
          intermediate(2*j) = intermediate(2*j) + dummy1(2)
        ENDDO
      ENDDO
      DO j=1,nelec
        CALL PUSHREAL8ARRAY(dummy1, 2)
        CALL MULTCMPLX(dets(1), dets(2), intermediate(2*j-1), 
     +                 intermediate(2*j), dummy1)
        CALL PUSHINTEGER4(result1)
        result1 = IND(orb1, j - 1, nelec)
        CALL PUSHINTEGER4(result2)
        result2 = IND(orb1, j - 1, nelec)
      ENDDO
C***************************
C
C
      CALL EVALS(braj, ketj, s, norbs, ketjncol, nelec)
C*****THIS IS THE SECOND TERM
Crdm = det(S) Tr(Sinv * S) ketJ(orb2, i) * Sinv(i, j) * braJGiven(orb1, j)
C
      trsinvs(1) = 0.
      trsinvs(2) = 0.
      DO i=1,nelec
        DO j=1,nelec
          CALL PUSHINTEGER4(result1)
          result1 = IND(i - 1, j - 1, sinvncol)
          CALL PUSHINTEGER4(ind1)
          ind1 = 2*result1 - 1
          result1 = IND(j - 1, i - 1, nelec)
          CALL PUSHINTEGER4(ind2)
          ind2 = 2*result1 - 1
          CALL PUSHREAL8ARRAY(dummy1, 2)
          CALL MULTCMPLX(sinv(ind1), sinv(ind1+1), s(ind2), s(ind2+1), 
     +                   dummy1)
          trsinvs(1) = trsinvs(1) + dummy1(1)
          trsinvs(2) = trsinvs(2) + dummy1(2)
        ENDDO
      ENDDO
      CALL MULTCMPLX(dets(1), dets(2), trsinvs(1), trsinvs(2), dummy2)
      DO j=1,nelec
        CALL PUSHINTEGER4(result1)
        result1 = IND(orb1, j - 1, brajgivenncol)
        CALL PUSHINTEGER4(ind1)
        ind1 = 2*result1 - 1
        CALL PUSHREAL8ARRAY(dummy1, 2)
        CALL MULTCMPLX(intermediate(2*j-1), intermediate(2*j), brajgiven
     +                 (ind1), brajgiven(ind1+1), dummy1)
C
      ENDDO
C
      DO i=1,nelec
        intermediate2(2*i-1) = 0.0
        intermediate2(2*i) = 0.0
C         intermediate2(i) = (0., 0.)
        DO j=1,nelec
          CALL PUSHINTEGER4(result1)
          result1 = IND(i - 1, j - 1, sinvncol)
          CALL PUSHINTEGER4(result2)
          result2 = IND(i - 1, j - 1, sinvncol)
          CALL PUSHREAL8ARRAY(dummy1, 2)
          CALL MULTCMPLX(intermediate(2*j-1), intermediate(2*j), s(2*
     +                   result1-1), s(2*result2), dummy1)
C
          intermediate2(2*i-1) = intermediate2(2*i-1) + dummy1(1)
          intermediate2(2*i) = intermediate2(2*i) + dummy1(2)
        ENDDO
      ENDDO
C            intermediate2(i) = intermediate2(i) +   
C     c           intermediate(j) * 
C     c           S(ind(i-1,    j-1, SinvNcol)) 
Cintermediate = intermediate2 * Sinv
C
      DO i=1,nelec
        CALL PUSHREAL8(intermediate(2*i-1))
        intermediate(2*i-1) = 0.0
        CALL PUSHREAL8(intermediate(2*i))
        intermediate(2*i) = 0.0
C         intermediate(i) = (0., 0.)
        DO j=1,nelec
          CALL PUSHINTEGER4(result1)
          result1 = IND(i - 1, j - 1, sinvncol)
          CALL PUSHINTEGER4(result2)
          result2 = IND(i - 1, j - 1, sinvncol)
          CALL PUSHREAL8ARRAY(dummy1, 2)
          CALL MULTCMPLX(intermediate2(2*j-1), intermediate2(2*j), sinv(
     +                   2*result1-1), sinv(2*result2), dummy1)
C
          CALL PUSHREAL8(intermediate(2*i-1))
          intermediate(2*i-1) = intermediate(2*i-1) + dummy1(1)
          CALL PUSHREAL8(intermediate(2*i))
          intermediate(2*i) = intermediate(2*i) + dummy1(2)
        ENDDO
      ENDDO
C
C            intermediate(i) = intermediate(i) +   
C     c           intermediate2(j) * 
C     c           Sinv(ind(i-1,    j-1, SinvNcol)) 
C*****THIS IS THE THIRD TERM
Crdmcmplx += detS*intermediate*braJ
C
      DO j=1,nelec
        CALL PUSHREAL8ARRAY(dummy1, 2)
        CALL MULTCMPLX(dets(1), dets(2), intermediate(2*j-1), 
     +                 intermediate(2*j), dummy1)
        CALL PUSHINTEGER4(result1)
        result1 = IND(orb1, j - 1, nelec)
        CALL PUSHINTEGER4(result2)
        result2 = IND(orb1, j - 1, nelec)
      ENDDO
      DO ii1=1,2*nelec
        intermediateb(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        dummy1b(ii1) = 0.0
      ENDDO
      DO j=nelec,1,-1
        result3b = -rdmb
        DO ii1=1,2*norbs*nelec
          brajgivenb(ii1) = 0.0
        ENDDO
        CALL MULTREAL_B(dummy1(1), dummy1b(1), dummy1(2), dummy1b(2), 
     +                  brajgiven(2*result1-1), brajgivenb(2*result1-1)
     +                  , brajgiven(2*result2), brajgivenb(2*result2), 
     +                  result3b)
        CALL POPINTEGER4(result2)
        CALL POPINTEGER4(result1)
        CALL POPREAL8ARRAY(dummy1, 2)
        DO ii1=1,2
          detsb(ii1) = 0.0
        ENDDO
        CALL MULTCMPLX_B(dets(1), detsb(1), dets(2), detsb(2), 
     +                   intermediate(2*j-1), intermediateb(2*j-1), 
     +                   intermediate(2*j), intermediateb(2*j), dummy1, 
     +                   dummy1b)
      ENDDO
      DO ii1=1,2*nelec
        intermediate2b(ii1) = 0.0
      ENDDO
      DO i=nelec,1,-1
        DO j=nelec,1,-1
          CALL POPREAL8(intermediate(2*i))
          dummy1b(2) = dummy1b(2) + intermediateb(2*i)
          CALL POPREAL8(intermediate(2*i-1))
          dummy1b(1) = dummy1b(1) + intermediateb(2*i-1)
          CALL POPREAL8ARRAY(dummy1, 2)
          DO ii1=1,2*nelec*nelec
            sinvb(ii1) = 0.0
          ENDDO
          CALL MULTCMPLX_B(intermediate2(2*j-1), intermediate2b(2*j-1), 
     +                     intermediate2(2*j), intermediate2b(2*j), sinv
     +                     (2*result1-1), sinvb(2*result1-1), sinv(2*
     +                     result2), sinvb(2*result2), dummy1, dummy1b)
          CALL POPINTEGER4(result2)
          CALL POPINTEGER4(result1)
        ENDDO
        CALL POPREAL8(intermediate(2*i))
        intermediateb(2*i) = 0.D0
        CALL POPREAL8(intermediate(2*i-1))
        intermediateb(2*i-1) = 0.D0
      ENDDO
      DO ii1=1,2*nelec*nelec
        sb(ii1) = 0.0
      ENDDO
      DO i=nelec,1,-1
        DO j=nelec,1,-1
          dummy1b(2) = dummy1b(2) + intermediate2b(2*i)
          dummy1b(1) = dummy1b(1) + intermediate2b(2*i-1)
          CALL POPREAL8ARRAY(dummy1, 2)
          DO ii1=1,2*nelec
            intermediateb(ii1) = 0.0
          ENDDO
          CALL MULTCMPLX_B(intermediate(2*j-1), intermediateb(2*j-1), 
     +                     intermediate(2*j), intermediateb(2*j), s(2*
     +                     result1-1), sb(2*result1-1), s(2*result2), sb
     +                     (2*result2), dummy1, dummy1b)
          CALL POPINTEGER4(result2)
          CALL POPINTEGER4(result1)
        ENDDO
        intermediate2b(2*i) = 0.D0
        intermediate2b(2*i-1) = 0.D0
      ENDDO
      DO ii1=1,2
        dummy2b(ii1) = 0.0
      ENDDO
      DO j=nelec,1,-1
        result10b = rdmb
        CALL MULTREAL_B(dummy2(1), dummy2b(1), dummy2(2), dummy2b(2), 
     +                  dummy1(1), dummy1b(1), dummy1(2), dummy1b(2), 
     +                  result10b)
        CALL POPREAL8ARRAY(dummy1, 2)
        DO ii1=1,2*nelec
          intermediateb(ii1) = 0.0
        ENDDO
        DO ii1=1,2*norbs*nelec
          brajgivenb(ii1) = 0.0
        ENDDO
        CALL MULTCMPLX_B(intermediate(2*j-1), intermediateb(2*j-1), 
     +                   intermediate(2*j), intermediateb(2*j), 
     +                   brajgiven(ind1), brajgivenb(ind1), brajgiven(
     +                   ind1+1), brajgivenb(ind1+1), dummy1, dummy1b)
        CALL POPINTEGER4(ind1)
        CALL POPINTEGER4(result1)
      ENDDO
      DO ii1=1,2
        detsb(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        trsinvsb(ii1) = 0.0
      ENDDO
      CALL MULTCMPLX_B(dets(1), detsb(1), dets(2), detsb(2), trsinvs(1)
     +                 , trsinvsb(1), trsinvs(2), trsinvsb(2), dummy2, 
     +                 dummy2b)
      DO i=nelec,1,-1
        DO j=nelec,1,-1
          dummy1b(2) = dummy1b(2) + trsinvsb(2)
          dummy1b(1) = dummy1b(1) + trsinvsb(1)
          CALL POPREAL8ARRAY(dummy1, 2)
          DO ii1=1,2*nelec*nelec
            sinvb(ii1) = 0.0
          ENDDO
          CALL MULTCMPLX_B(sinv(ind1), sinvb(ind1), sinv(ind1+1), sinvb(
     +                     ind1+1), s(ind2), sb(ind2), s(ind2+1), sb(
     +                     ind2+1), dummy1, dummy1b)
          CALL POPINTEGER4(ind2)
          CALL POPINTEGER4(ind1)
          CALL POPINTEGER4(result1)
        ENDDO
      ENDDO
      CALL EVALS_B(braj, brajb, ketj, ketjb, s, sb, norbs, ketjncol, 
     +             nelec)
      DO j=nelec,1,-1
        result3b = rdmb
        DO ii1=1,2
          dummy1b(ii1) = 0.0
        ENDDO
        CALL MULTREAL_B(dummy1(1), dummy1b(1), dummy1(2), dummy1b(2), 
     +                  braj(2*result1-1), brajb(2*result1-1), braj(2*
     +                  result2), brajb(2*result2), result3b)
        CALL POPINTEGER4(result2)
        CALL POPINTEGER4(result1)
        CALL POPREAL8ARRAY(dummy1, 2)
      ENDDO
      DO j=nelec,1,-1
        DO i=nelec,1,-1
          CALL POPINTEGER4(ind2)
          CALL POPINTEGER4(ind1)
        ENDDO
      ENDDO
      CALL EVALBRAJ_B(braj, brajb, bra, jai, jaib, brancol, nelec, norbs
     +               )
      rdmb = 0.0
      END

C  Differentiation of evalbraj in reverse (adjoint) mode:
C   gradient     of useful results: braj
C   with respect to varying inputs: jai
C
C************************************************
C evalbraJ
C************************************************
      SUBROUTINE EVALBRAJ_B(braj, brajb, bra, jai, jaib, brancol, nelec
     +                      , norbs)
      IMPLICIT NONE
C
      INTEGER brancol, nelec, i, j, norbs, IND
      REAL*8 braj(2*norbs*nelec)
      REAL*8 brajb(2*norbs*nelec)
      REAL*8 bra(2*norbs*nelec)
CbraJ = exp(J) * bra
      REAL*8 jai(norbs)
      REAL*8 jaib(norbs)
      INTRINSIC EXP
      INTEGER result1
      INTEGER result2
      INTEGER ii1
C
      DO i=1,norbs
        DO j=1,nelec
          CALL PUSHINTEGER4(result1)
          result1 = IND(i - 1, j - 1, nelec)
          CALL PUSHINTEGER4(result2)
          result2 = IND(i - 1, j - 1, brancol)
C
          CALL PUSHINTEGER4(result1)
          result1 = IND(i - 1, j - 1, nelec)
          CALL PUSHINTEGER4(result2)
          result2 = IND(i - 1, j - 1, brancol)
        ENDDO
      ENDDO
      DO ii1=1,norbs
        jaib(ii1) = 0.0
      ENDDO
      DO i=norbs,1,-1
        DO j=nelec,1,-1
          jaib(i) = jaib(i) - EXP(-(2.*jai(i)))*bra(2*result2)*2.*brajb(
     +      2*result1)
          brajb(2*result1) = 0.D0
          CALL POPINTEGER4(result2)
          CALL POPINTEGER4(result1)
          jaib(i) = jaib(i) - EXP(-(2.*jai(i)))*bra(2*result2-1)*2.*
     +      brajb(2*result1-1)
          brajb(2*result1-1) = 0.D0
          CALL POPINTEGER4(result2)
          CALL POPINTEGER4(result1)
        ENDDO
      ENDDO
      END

C  Differentiation of evals in reverse (adjoint) mode:
C   gradient     of useful results: s
C   with respect to varying inputs: braj
C
C************************************************
C evalS
C************************************************
      SUBROUTINE EVALS_B(braj, brajb, ketj, ketjb, s, sb, norbs, 
     +                   ketjncol, nelec)
      IMPLICIT NONE
C
C               S(ind(i-1, j-1, nelec)) = S(ind(i-1, j-1, nelec)) + 
C     c              braJ(ind(k-1, i-1, nelec)) 
C     c              * ketJ(ind(k-1, j-1, ketJNcol))
      INTEGER norbs, nelec, i, j, k, IND
      INTEGER brancol, ketjncol, ind1, ind2, ind3
      REAL*8 s(2*nelec*nelec), dummy(2)
      REAL*8 sb(2*nelec*nelec), dummyb(2)
      REAL*8 ketj(2*norbs*nelec)
      REAL*8 ketjb(2*norbs*nelec)
      REAL*8 braj(2*norbs*nelec)
      REAL*8 brajb(2*norbs*nelec)
      INTEGER ii1
CS = braJ^T ketJ
CS-> nelec, nelec
CbraJ -> norbs, nelec
CketJ -> norbs, nelec
C
      DO i=1,nelec
        DO k=1,norbs
          DO j=1,nelec
            CALL PUSHINTEGER4(ind1)
            ind1 = IND(i - 1, j - 1, nelec)
            CALL PUSHINTEGER4(ind2)
            ind2 = IND(k - 1, i - 1, nelec)
            CALL PUSHINTEGER4(ind3)
            ind3 = IND(k - 1, j - 1, nelec)
C
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,2*norbs*nelec
        brajb(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        dummyb(ii1) = 0.0
      ENDDO
      DO i=nelec,1,-1
        DO k=norbs,1,-1
          DO j=nelec,1,-1
            dummyb(2) = dummyb(2) + sb(2*ind1)
            dummyb(1) = dummyb(1) + sb(2*ind1-1)
            DO ii1=1,2*norbs*nelec
              ketjb(ii1) = 0.0
            ENDDO
            CALL MULTCMPLX_B(braj(2*ind2-1), brajb(2*ind2-1), braj(2*
     +                       ind2), brajb(2*ind2), ketj(2*ind3-1), ketjb
     +                       (2*ind3-1), ketj(2*ind3), ketjb(2*ind3), 
     +                       dummy, dummyb)
            CALL POPINTEGER4(ind3)
            CALL POPINTEGER4(ind2)
            CALL POPINTEGER4(ind1)
          ENDDO
        ENDDO
      ENDDO
      END

C  Differentiation of multcmplx in reverse (adjoint) mode:
C   gradient     of useful results: a1 a2 b1 b2 c
C   with respect to varying inputs: a1 a2 b1 b2 c
C
      SUBROUTINE MULTCMPLX_B(a1, a1b, a2, a2b, b1, b1b, b2, b2b, c, cb)
      IMPLICIT NONE
      REAL*8 a1, a2, b1, b2, c(2), MULTREAL, MULTIMAG
      REAL*8 a1b, a2b, b1b, b2b, cb(2)
      CALL MULTIMAG_B(a1, a1b, a2, a2b, b1, b1b, b2, b2b, cb(2))
      cb(2) = 0.0
      CALL MULTREAL_B(a1, a1b, a2, a2b, b1, b1b, b2, b2b, cb(1))
      cb(1) = 0.0
      END

C  Differentiation of multreal in reverse (adjoint) mode:
C   gradient     of useful results: a1 a2 b1 b2 c
C   with respect to varying inputs: a1 a2 b1 b2
      SUBROUTINE MULTREAL_B(a1, a1b, a2, a2b, b1, b1b, b2, b2b, cb)
      IMPLICIT NONE
      REAL*8 a1, a2, b1, b2, c
      REAL*8 a1b, a2b, b1b, b2b, cb
      a1b = a1b + b1*cb
      b1b = b1b + a1*cb
      a2b = a2b - b2*cb
      b2b = b2b - a2*cb
      END

C  Differentiation of multimag in reverse (adjoint) mode:
C   gradient     of useful results: a1 a2 b1 b2 c
C   with respect to varying inputs: a1 a2 b1 b2
C
      SUBROUTINE MULTIMAG_B(a1, a1b, a2, a2b, b1, b1b, b2, b2b, cb)
      IMPLICIT NONE
      REAL*8 a1, a2, b1, b2, c
      REAL*8 a1b, a2b, b1b, b2b, cb
      a1b = a1b + b2*cb
      b2b = b2b + a1*cb
      a2b = a2b + b1*cb
      b1b = b1b + a2*cb
      END
